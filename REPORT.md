# A34 MediTrack Project Report

## 1. Introduction

In response to the growing need for enhanced security in managing patient data within Portugal's healthcare institutions, our project focuses on fortifying the MediTrack Electronic Health Records (EHR) system. The primary components of our project include the development of a secure document format, the establishment of a robust infrastructure, and addressing specific security challenges inherent in healthcare data management.


## 2. Project Development

### 2.1. Secure Document Format

#### 2.1.1. Design

Our custom cryptographic library, implemented in Java using the Java Cryptography Architecture (JCA), is meticulously designed to uphold the authenticity and confidentiality of patient data within the MediTrack EHR system. The following is an illustrative example of our data format, showcasing the designed protections.

1. Unprotected Document
``` json
{
  "content": "request/response here",
  "digital-signature": "digital-signature-here",
  "token": "freshness-token-here"
}
```

2. Protected document
``` json
{
  "value": [
    "content-encrypted-here",
    "secret-key-here"
  ],
  "digital-signature": "digital-signature-here",
  "token": "freshness-token-here"
}
```

- Content: Encrypted with the secret.key and cipher "AES". Constains the instructons of the request/response between API and Client. 
- Secret Key: Generated in the protected function with 256 bytes and "AES" algorithm. Is generated a new secret key for every protected document and is send in the "value" encrypted with the receiver's public key;
- Digital Signature: Generated with the private key of the sender's and signature "SHA256withRSA", and updated by the content.
- Freshnesn Token: Generated by a timestamp and a random value with the algorithmn "SHA1PRNG". 

Note: the freshness-token and the digital signature are validated with the check function of the Security Documents.


#### 2.1.2. Implementation

The implementation of our custom cryptographic library was carried out in Java, utilizing the Java Cryptography Architecture (JCA) for encryption and digital signature operations.

Digital Signature (Authenticity): Utilized JCA for asymmetric cryptography, generating and verifying digital signatures with a securely held private key and shared public key for users.

Token (Freshness): This token acts as a safeguard against tampering and replay attacks. By incorporating a timestamp, it enables tracking of the token's creation time. The inclusion of a random value strengthens security by introducing unpredictability, making it challenging for attackers to manipulate the token. Moreover, the random value serves a vital role in identifying potential security breaches. 


### 2.2. Infrastructure

#### 2.2.1. Network and Machine Setup

In this project, we utilized four virtual machines, which we'll refer to as API, DB, DMZ, and Client. The API machine is connected to two internal networks, "sw-0" and "sw-1," linking to the DMZ and the API, respectively. The DB machine is connected to two internal networks, "sw-1" and "sw-3." "sw-1" connects to the API, and "sw-3" is linked to the DMZ but serves solely for bootstrap purposes. The Client machine has two networks: an internal one connecting to the DMZ to simulate access to a web server and a NAT for internet access.
The DMZ encompasses four networks: three internal networks, "sw-0," "sw-2," and "sw-3," and a NAT that provides internet access to machines in the local network. We've designated the DMZ as the default gateway for these machines, allowing them to access the internet.

#### 2.2.2. API Communication Security

In out case, the API needed to stablish 2 types of secure communications: with the databse and with the Client through the DMZ.
For both types of communication the content of the messages are encrypted using the SecureDocument library.

1. Secure Sockets
The first communication refered was stablished through secure sockets. We created the certificates and the respectibe thrustores the Database has the server-side of this communication, listening for the API requests and creating a loop to process multiple requests, and the API has the client-side of this communications,stablishing connection when a query is ready to be executed in the database. 

For this communications we created a script "generateCertificates.sh" to allow the creation of all the certificates, clients and thrustore needed. Although this won't be needed as all the certificates and keys are already in the project documents, ready to be used.

2. HTTPS
For the communications between the Client and the API we used HTTPS connections through the "https://localhost:443/api" URL. In this case, the API has the server-side of the communication and the Client (Patient or Doctor) as the client-side, and here the communication is always started the client. To ensure that the communication was secure we also used the "generateCertificates.sh" to create the client's certificates.


### 2.3. Security Challenge

#### 2.3.1. Challenge Overview

Out challenge consisted on the emergency scenario.
In the regular case, a doctor would only be able to access the basic patients informations and the consultations that where given by him or allowed by the patient. Although this limitation should be able to be overwritten in a emergency. In this very particular moments the doctos is able to access all patients information, without needing their previous authorization.

#### 2.3.2. Attacker Model

In SOS mode, trust is extended fully to every doctor. In a regular mode, doctors hold partial trust: they can access and create consultations, altering patient records with patient authorization required for viewing other consultations. Patients, deemed untrusted, can only view their records, delete their accounts in adherence to data protection laws, and permit doctors to access their records.

Vulnerability depends on the attacker's intentions. In SOS mode, despite granting access to all patient medical information with a 2-minute time limit, the doctor must reauthenticate after activation. If the goal is to harm patients, the attacker can delete their information but cannot access it.

If the intention is to fabricate consultations, the attacker, posing as a regular doctor, can add specific consultations but is barred from altering personal patient details.


#### 2.3.3. Solution Design and Implementation

This challenge resulted in changing the queries that are process by the database and in adding a timestamp variable to the API that stores the time on when the sos mode was activated and when the "See patients consultations" function is displayed, if the SOS flag is on, and the current time is less that 2 min after the activation time them the query does not include the condition on the authorizations table to verify the doctors authorizations and only verifies the patient.
 

## 3. Conclusion


### Main achievements
The successful implementation of the Secure On-Demand Access (SOS) mode was probably our main achivement in this project. This feature empowers doctors with instantaneous access to the patient full medical information within a defined timeframe, fortified by a resilient reauthentication process.


### Requirements
Our project has effectively met primary requirements, particularly in establishing secure access control for both doctors and patients. However, nuanced areas of partial satisfaction have surfaced, notably in navigating access permissions within the regular mode. Patient authorization for specific consultations introduces a deliberate layer of privacy, with potential limitations in user experience. 

The authentication process aligns with the core objective of ensuring that the user presenting the public key indeed possesses the corresponding private key.
The authentication process was simplified but also satisfied the main goal of ensuring that the user presenting the public key indeed possesses the corresponding private key.

For simplification purposes, we assumed a shared key pair for all patients and doctors. Despite its departure from real-world scenarios, this approach filters requests by username, maintaining a robust security stance. Unregistered patients receive only empty responses, adding an additional layer of data protection.


### Possibly enhancements in the future
 - Usability of Public Keys: While secret keys are dynamically generated in each communication, the handling of the public keys should be revised.

- Database Selection: During the project we identified limitations in the encryption-at-rest feature of SQLite. Future considerations could explore transitioning to more robust databases like MySQL or PostgreSQL to enhance overall data security.

- Functionality Expansion: Time constraints led to the prioritization of basic functions in the patient and doctors menu. Subsequent iterations could unlock the full potential of the project, introducing new functionalities.

Note: In this project, we assume that the private key can't be stolen. We consider the ownership of the private keys as the unequivocal validation ensuring the identity of users. 

### Conclusion
This was a very complete project: starting with the creation of the crypto library in Java (SecureDocuments), where we gained insights into cryptography algorithms and their practical implementation and ending with the construction of a secure infrastructure from the ground up, where we learned the diverse communication methods between machines such as secure sockets, HTTPS requests, routing communications between different machines and implementing effective firewall configurations.

Finally, the security challenge forced us to address a specific problem in the healthcare sector, demanding an original approach to problem-solving. This stage not only deepened our technical expertise but also emphasized the significance of adaptability in translating theoretical knowledge into practical solutions for real-world situations.

## 4. Bibliography

Authores:
- Francisco Gil Mata
- Luis Marques
- Marta Félix

Title: Meditrack - SIRS project

Published: https://github.com/tecnico-sec/a34-francisco-marta-luis/

Year: 2023/2024

----
END OF REPORT
