# A34 MediTrack Project Report

## 1. Introduction

In response to the growing need for enhanced security in managing patient data within Portugal's healthcare institutions, our project focuses on fortifying the MediTrack Electronic Health Records (EHR) system. The primary components of our project include the development of a secure document format, the establishment of a robust infrastructure, and addressing specific security challenges inherent in healthcare data management.


## 2. Project Development

### 2.1. Secure Document Format

#### 2.1.1. Design

Our custom cryptographic library, implemented in Java using the Java Cryptography Architecture (JCA), is meticulously designed to uphold the authenticity and confidentiality of patient data within the MediTrack EHR system. The following is an illustrative example of our data format, showcasing the designed protections.

1. Unprotected Document
``` json
{
  "content": "request/response here",
  "digital-signature": "digital-signature-here",
  "token": "freshness-token-here"
}
```

2. Protected document
``` json
{
  "value": [
    "content-encrypted-here",
    "secret-key-here"
  ],
  "digital-signature": "digital-signature-here",
  "token": "freshness-token-here"
}
```

content: encryted by the secret-key...
secret-key: generated by ....;
digital-signature: encrypted using... assures ....
freshness-token: generated by .... assures ..... 


#### 2.1.2. Implementation

(LUIS)
The implementation of our custom cryptographic library was carried out in Java, utilizing the Java Cryptography Architecture (JCA) for encryption and digital signature operations.

Digital Signature (Authenticity): Utilized JCA for asymmetric cryptography, generating and verifying digital signatures with a securely held private key and shared public key for users.

Encryption (Confidentiality): Leveraged JCA to apply the Advanced Encryption Standard (AES) for symmetric encryption, establishing a shared secret key through a secure key exchange mechanism.

Freshness-Token: Timestamp and counter methods .


### 2.2. Infrastructure

#### 2.2.1. Network and Machine Setup



(_Provide a brief description of the built infrastructure._)

(_Justify the choice of technologies for each server._)

#### 2.2.2. API Communication Security

In out case, the API needed to stablish 2 types of secure communications: with the databse and with the Client through the DMZ.

1. Secure Sockets
The first communication refered was stablished through secure sockets.We created the certificates and the respectibe thrustores the Database has the server-side of this communication, listening for the API requests and creating a loop to process multiple requests, and the API has the client-side of this communications,stablishing connection when a query is ready to be executed in the database. 

For this communications we created a script "generateCertificates.sh" to allow the creation of all the certificates, clients and thrustore needed. Although this won't be needed as all the certificates and keys are already in the project documents, ready to be used.

2. HTTPS
For the communication between the Client and the Api we used an HTTPS secure connection through the "https://localhost:443/api" URL. To ensure that the communication was secure we also used the "generateCertificates.sh" to create the client's certificates.

The comunication was allways started from the Client side and receved a response from the server



(_Discuss how server communications were secured, including the secure channel solutions implemented and any challenges encountered._)

(_Explain what keys exist at the start and how are they distributed?_)

### 2.3. Security Challenge

#### 2.3.1. Challenge Overview

Out challenge consisted on the emergency scenario.
In the regular case, a doctor would only be able to access the basic patients informations and the consultations that where given by him or allowed by the patient. Although this limitation should be able to be overwritten in a emergency. In this very particular moments the doctos is able to access all patients information, without needing their previous authorization.

#### 2.3.2. Attacker Model

In SOS mode, trust is extended fully to every doctor. In a regular mode, doctors hold partial trust: they can access and create consultations, altering patient records with patient authorization required for viewing other consultations. Patients, deemed untrusted, can only view their records, delete their accounts in adherence to data protection laws, and permit doctors to access their records.

Vulnerability depends on the attacker's intentions. In SOS mode, despite granting access to all patient medical information with a 2-minute time limit, the doctor must reauthenticate after activation. If the goal is to harm patients, the attacker can delete their information but cannot access it.

If the intention is to fabricate consultations, the attacker, posing as a regular doctor, can add specific consultations but is barred from altering personal patient details.

(_Define who is fully trusted, partially trusted, or untrusted._)

(_Define how powerful the attacker is, with capabilities and limitations, i.e., what can he do and what he cannot do_)

#### 2.3.3. Solution Design and Implementation

This challenge resulted in changing the queries that are process by the database and in adding a timestamp variable to the API that stores the time on when the sos mode was activated and when the "See patients consultations" function is displayed, if the SOS flag is on, and the current time is less that 2 min after the activation time them the query does not include the condition on the authorizations table to verify the doctors authorizations and only verifies the patient.

(_Explain how your team redesigned and extended the solution to meet the security challenge, including key distribution and other security measures._)

(_Identify communication entities and the messages they exchange with a UML sequence or collaboration diagram._)  

## 3. Conclusion


### Main achievements
The successful implementation of the Secure On-Demand Access (SOS) mode was probably our main achivement in this project. This feature empowers doctors with instantaneous access to the patient full medical information within a defined timeframe, fortified by a resilient reauthentication process.


### Requirements
Our project has effectively met primary requirements, particularly in establishing secure access control for both doctors and patients. However, nuanced areas of partial satisfaction have surfaced, notably in navigating access permissions within the regular mode. Patient authorization for specific consultations introduces a deliberate layer of privacy, with potential limitations in user experience. 

The authentication process aligns with the core objective of ensuring that the user presenting the public key indeed possesses the corresponding private key.
The authentication process was simplified but also satisfied the main goal of ensuring that the user presenting the public key indeed possesses the corresponding private key.

For simplification purposes, we assumed a shared key pair for all patients and doctors. Despite its departure from real-world scenarios, this approach filters requests by username, maintaining a robust security stance. Unregistered patients receive only empty responses, adding an additional layer of data protection.


### Possibly enhancements in the future
 - Usability of Public Keys: While secret keys are dynamically generated in each communication, the handling of the public keys should be revised.

- Database Selection: During the project we identified limitations in the encryption-at-rest feature of SQLite. Future considerations could explore transitioning to more robust databases like MySQL or PostgreSQL to enhance overall data security.

- Functionality Expansion: Time constraints led to the prioritization of basic functions in the patient and doctors menu. Subsequent iterations could unlock the full potential of the project, introducing new functionalities.

Note: In this project we assume that that private key cannot be stolen. The ownership of the private keys serves as ultimate validation to assure the users identity.

### Conclusion
This was a very complete project: starting with the creation of the crypto library in Java (SecureDocuments), where we gained insights into cryptography algorithms and their practical implementation and ending with the construction of a secure infrastructure from the ground up, where we learned the diverse communication methods between machines such as secure sockets, HTTPS requests, routing communications between different machines and implementing effective firewall configurations.

Finally, the security challenge forced us to address a specific problem in the healthcare sector, demanding an original approach to problem-solving. This stage not only deepened our technical expertise but also emphasized the significance of adaptability in translating theoretical knowledge into practical solutions for real-world situations.

## 4. Bibliography

(_Present bibliographic references, with clickable links. Always include at least the authors, title, "where published", and year._)

----
END OF REPORT
